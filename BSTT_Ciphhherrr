#  File: BST_Cipher.py

#  Description:

#  Student Name:

#  Student UT EID:

#  Partner Name:

#  Partner UT EID:

#  Course Name: CS 313E

#  Unique Number:

#  Date Created:

#  Date Last Modified:

class Node (object):
  def __init__ (self, data):
    self.data = data
    self.lchild = None
    self.rchild = None

class Tree (object):
  # the init() function creates the binary search tree with the
  # encryption string. If the encryption string contains any
  # character other than the characters 'a' through 'z' or the
  # space character drop that character.
  def __init__ (self, encrypt_str):
    self.root = None

    for i in encrypt_str:
      if (i.isalpha() == True):
        self.insert(i)



  # the insert() function adds a node containing a character in
  # the binary search tree. If the character already exists, it
  # does not add that character. There are no duplicate characters
  # in the binary search tree.
  # Works(Wooo)
  def insert (self, ch):
    new_node = Node (ch)

    if (self.root == None):
      self.root = new_node

    else:
      current = self.root
      parent = self.root

      while (current != None):
        parent = current
        if (ch < current.data):
          current = current.lchild

        elif (ch == current.data):
          break

        else:
          current = current.rchild

      if (ch < parent.data):
        parent.lchild = new_node

      else:
        parent.rchild = new_node

  # the search() function will search for a character in the binary
  # search tree and return a string containing a series of lefts
  # (<) and rights (>) needed to reach that character. It will
  # return a blank string if the character does not exist in the tree.
  # It will return * if the character is the root of the tree.
  # Works(Wooo)
  def search (self, ch):
    direction_string = ""
    left = "<"
    right = ">"
    root_star = "*"
    if (self.root != None):
      current = self.root
      parent = self.root
      if (current == ch):
        return root_star
      while (current != None):
        parent = current
        if (ch < current.data):
          current = current.lchild
          direction_string = direction_string + left
        elif (ch == current.data):
          break
        else:
          current = current.rchild
          direction_string = direction_string + right

      if (current == None):
        direction_string = ""

    return direction_string

  # the traverse() function will take string composed of a series of
  # lefts (<) and rights (>) and return the corresponding
  # character in the binary search tree. It will return an empty string
  # if the input parameter does not lead to a valid character in the tree.
  # Works(Wooo)
  def traverse (self, st):
    current = self.root
    if (st == "*"):
      return current.data
    else:
      for i in st:
        if current == None:
          return ""
        else:
          if (current == ">"):
            current = current.rchild
          elif (current == "<"):
            current = current.lchild

    return current.data

  # the encrypt() function will take a string as input parameter, convert
  # it to lower case, and return the encrypted string. It will ignore
  # all digits, punctuation marks, and special characters.
  def encrypt (self, st):
  # Create new string with only letters
  # Make the new_string lower case
  # new_string = new_string.lower()
  repeat_string = ""
  alpha_space_string = ""
  new_string = ""
  # Make st Lower Case
  stl = st.lower()
  for i in stl:
    if (i == "" or i.isalpha()):
      if (repeat_string.find(i) != -1):
        alpha_space_string = alpha_space_string + i
        repeat_string = repeat_string + i
  for i in alpha_space_string:
    current = self.search(i)
    new_string = new_string + encrypt + "!"

  return new_string[0:-1]

  # the decrypt() function will take a string as input parameter, and
  # return the decrypted string.
  # Use TRAVERSE
  def decrypt (self, st):


def main():
    e_key = input("Enter encryption key: ")
    #
    #
    # key_to_life = Tree(e_key)
    e_string = input("Enter string to be encrypted: ")
    #
    #
    d_string = input("Enter string to be encrypted: ")

main()
